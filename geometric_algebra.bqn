âŸ¨ Algebra âŸ©â‡

Algebra â† {
  pâ€¿qâ€¿r â† ğ•©
  num_dimensions â† âŒŠ +Â´ ğ•©
  num_basis â† 2â‹†num_dimensions
	
	one_vector_metric â† 1â€¿râ€¿pâ€¿q / 1â€¿0â€¿1â€¿Â¯1

	nameset â† 1+â†•num_dimensions
  FromBase2 â† {+Â´ğ•©Ã—2â‹†â†•â‰ ğ•©}

  bits â† âŒŠ 2 | (â†•2â‹†num_dimensions) Ã·âŒœ 2â‹†â†•num_dimensions
  name â† namesetâŠ¸Ã—Ë˜ bits
	metric â† Ã—Â´Ë˜ name âŠ one_vector_metric
  grades â† +Â´Ë˜ bits
  
	cayley â† {
    a_bits â† ğ•¨ âŠ bits
    b_bits â† ğ•© âŠ bits
    basis â† FromBase2 a_bits â‰  b_bits
    a_name â† ğ•¨ âŠ name
    b_name â† ğ•© âŠ name
    match_sign â† metric âŠ‘Ëœ FromBase2 a_bits âˆ§ b_bits
		sign â† ((ğ•¨=0) âˆ¨ (ğ•©=0))â—¶âŸ¨{ğ•¤
		  elim â† a_bits âˆ§ b_bits
      ae â† a_bits â‰  elim
      be â† b_bits â‰  elim
      an â† ae / (ae Ã— â†•num_dimensions)
      bn â† be / (be Ã— â†•num_dimensions)
      Â¯1â‹† +Â´ â¥Š an >âŒœ bn
		}, 1Ë™âŸ© @
    (match_sign Ã— sign)â€¿basis
	}âŒœËœ â†•2â‹†num_dimensions

	cayley_sign â† 0âŠ‘Â¨cayley
	cayley_basis â† 1âŠ‘Â¨cayley
	cayley_grade â† cayley_basis âŠ grades

	_mkMultivector â† {ğ”½â—‹(â†‘ËœâŸœnum_basis)}

	One â‡ âŠ‘
	E â‡ {
    Â» âŒ½ num_basis -âŠ¸â†‘ 1 â†‘Ëœ +Â´ 2 â‹† â¥Š ğ•©
  }

  _mkProduct â† {
		sign â† ğ•— Ã— cayley_sign
		{   ğ•Š a : Ã— One a ;
		  a ğ•Š b : +Â´Ë˜ a Ã—â‰1 sign Ã— cayley_basis âŠ b
		} _mkMultivector
  }

  Add â‡ + _mkMultivector
  Subtract â‡ - _mkMultivector

	GeometricProduct â‡ (1Ë™âŒœËœ grades) _mkProduct
	ExteriorProduct â‡ (cayley_grade = +âŒœËœ grades) _mkProduct
	LeftInnerProduct â‡ (cayley_grade = -ËœâŒœËœ grades) _mkProduct
	RightInnerProduct â‡ (cayley_grade = -âŒœËœ grades) _mkProduct
	RegressiveProduct â‡ (cayley_grade = -âŒœËœ grades) _mkProduct

	InnerProduct â‡ LeftInnerProduct

	Log â‡ {
    ""Ë™ ğ•©
  }

	Negate â‡ -âˆ˜â†‘ËœâŸœnum_basis
	Reverse â‡ (1â€¿1â€¿Â¯1â€¿Â¯1 âŠËœ 4 | grades)âŠ¸Ã— _mkMultivector
	Involute â‡ (1â€¿Â¯1â€¿1â€¿Â¯1 âŠËœ 4 | grades)âŠ¸Ã— _mkMultivector
	Conjugate â‡ (1â€¿Â¯1â€¿Â¯1â€¿1 âŠËœ 4 | grades)âŠ¸Ã— _mkMultivector
  
  Inverse â‡ ((5âŒŠnum_dimensions)â—¶Ã·â€¿{
    i â† Involute ğ•©
    i Ã·âŸœOne (ğ•© GeometricProduct i)
  }â€¿{
    c â† Conjugate ğ•©
    c Ã·âŸœOne (ğ•© GeometricProduct c)
  }â€¿{
    i â† Involute ğ•©
    c â† Conjugate ğ•©
    r â† Reverse ğ•©
    left â† GeometricProductÂ´ râ€¿iâ€¿c
    right â† GeometricProductÂ´ ğ•©â€¿câ€¿iâ€¿r
    left Ã·âŸœOne right
  }â€¿{
    c â† Conjugate ğ•©
    xc â† ğ•© GeometricProduct c
    mxc â† (grades âˆŠ 3â€¿4) Ã— xc
    (c GeometricProduct mxc) Ã·âŸœOne (xc GeometricProduct mxc)
  }â€¿{
    #c â† Conjugate ğ•©
    #i â† Involute ğ•©
    #r â† Reverse ğ•©
    #cir â† c Mul i Mul r
    #mxcir â† 1â€¿4 Map ğ•© Mul cir
    #cirmxcir â† cir Mul mxcir
    #left â† cirmxcir
    #right â† ğ•© Mul cirmxcir
    #left Ã·âŸœOne right
    ğ•©
  }â€¿{
    # shirokov inverse
    #n â† 2â‹†âŒŠ(tot+1Ã·2)
    #self â† ğ•©
    #uk â† 1 { self Mul ğ•¨ Sub ğ•© Ã— One ğ•¨ }Â´ nâŠ¸Ã·Â¨ 1â†“â†•n
    ğ•©
  }) _mkMultivector

  Divide â‡ { Inverse ğ•© ; ğ•¨ GeometricProduct Inverse ğ•© }

  Length â‡ { âˆš | One ğ•© GeometricProduct Conjugate ğ•© } _mkMultivector
  Normalize â‡ { ğ•© Ã— Ã· Length ğ•© }
  
  Sandwich â‡ { ğ•¨ GeometricProduct ğ•© GeometricProduct Reverse ğ•¨ }
}
