âŸ¨ Algebra âŸ©â‡

Algebra â† {
  dimensions â† ğ•©
  pâ€¿qâ€¿r â† dimensions
  num_dimensions â† +Â´ dimensions
  num_basis â† 2â‹†num_dimensions
  one_vector_metric â† 1â€¿râ€¿pâ€¿q / 1â€¿0â€¿1â€¿Â¯1
  full_name â† 1+â†•num_dimensions
  bits â† (â‹âˆ˜(+Â´Â¨))âŠ¸âŠ âŒ½Â¨ â¥Šâ†•num_dimensionsâ¥Š2
  name â† full_nameâŠ¸Ã—Â¨ bits
  ename â† "" <âŠ¸âˆ¾ 1â†“ bits { 'e' <âŠ¸âˆ¾ '0' + ğ•¨/ğ•© - r>0 }Â¨ name
  grade â† +Â´Â¨ bits
  cayley_basis â† bits âŠ â‰ âŒœËœ bits
  cayley_match â† âˆ§âŒœËœ bits
  cayley_match_sign â† Ã—Â´Â¨ âŠâŸœone_vector_metricÂ¨ full_nameâŠ¸Ã—Â¨ cayley_match
  cayley_swap_sign â† Â¯1 â‹† {+Â´ â¥Š ğ•©âŠ¸<Ë˜ ğ•¨}âŒœËœ (bits /Â¨ name)
  cayley_sign â† cayley_match_sign Ã— cayley_swap_sign
  cayley_grade â† cayley_basis âŠ grade

	_mkMultivector â† {ğ”½â—‹(â†‘ËœâŸœnum_basis)}

	One â‡ âŠ‘
	E â‡ {
  	num_basis â†‘ 1 â†‘Ëœ - 1 + âŠ‘ bits âŠ <full_name âˆŠ â¥Š (ğ•© + r>0)
  }

  _mkProduct â† {
		sign â† ğ•— Ã— cayley_sign
		{   ğ•Š a : Ã— One a ;
		  a ğ•Š b : +Â´Ë˜ a Ã—â‰1 sign Ã— cayley_basis âŠ b
		} _mkMultivector
  }

  Add â‡ + _mkMultivector
  Subtract â‡ - _mkMultivector

	GeometricProduct â‡ (1Ë™âŒœËœ grade) _mkProduct
	ExteriorProduct â‡ (cayley_grade = +âŒœËœ grade) _mkProduct
	LeftInnerProduct â‡ (cayley_grade = -ËœâŒœËœ grade) _mkProduct
	RightInnerProduct â‡ (cayley_grade = -âŒœËœ grade) _mkProduct
	RegressiveProduct â‡ (cayley_grade = -âŒœËœ grade) _mkProduct

	InnerProduct â‡ LeftInnerProduct

	Log â‡ {
  	num â† ğ•©
  	nz â† 0â‰ num
  	(âˆ¨Â´nz)â—¶{ğ•¤
		  ""
		}â€¿{ğ•¤
	    { ğ•¨âˆ¾" + "âˆ¾ğ•© }Â´ {xâ€¿y:(â€¢Fmt x) âˆ¾ y}Â¨ nz / num â‹ˆÂ¨ ename
		} @
  }

	Negate â‡ -âˆ˜â†‘ËœâŸœnum_basis
	Reverse â‡ (1â€¿1â€¿Â¯1â€¿Â¯1 âŠËœ 4 | grade)âŠ¸Ã— _mkMultivector
	Involute â‡ (1â€¿Â¯1â€¿1â€¿Â¯1 âŠËœ 4 | grade)âŠ¸Ã— _mkMultivector
	Conjugate â‡ (1â€¿Â¯1â€¿Â¯1â€¿1 âŠËœ 4 | grade)âŠ¸Ã— _mkMultivector
  
  Inverse â‡ ((5âŒŠnum_dimensions)â—¶Ã·â€¿{
    i â† Involute ğ•©
    i Ã·âŸœOne (ğ•© GeometricProduct i)
  }â€¿{
    c â† Conjugate ğ•©
    c Ã·âŸœOne (ğ•© GeometricProduct c)
  }â€¿{
    i â† Involute ğ•©
    c â† Conjugate ğ•©
    r â† Reverse ğ•©
    left â† GeometricProductÂ´ râ€¿iâ€¿c
    right â† GeometricProductÂ´ ğ•©â€¿câ€¿iâ€¿r
    left Ã·âŸœOne right
  }â€¿{
    c â† Conjugate ğ•©
    xc â† ğ•© GeometricProduct c
    mxc â† (grade âˆŠ 3â€¿4) Ã— xc
    (c GeometricProduct mxc) Ã·âŸœOne (xc GeometricProduct mxc)
  }â€¿{
    #c â† Conjugate ğ•©
    #i â† Involute ğ•©
    #r â† Reverse ğ•©
    #cir â† c Mul i Mul r
    #mxcir â† 1â€¿4 Map ğ•© Mul cir
    #cirmxcir â† cir Mul mxcir
    #left â† cirmxcir
    #right â† ğ•© Mul cirmxcir
    #left Ã·âŸœOne right
    ğ•©
  }â€¿{
    # shirokov inverse
    #n â† 2â‹†âŒŠ(tot+1Ã·2)
    #self â† ğ•©
    #uk â† 1 { self Mul ğ•¨ Sub ğ•© Ã— One ğ•¨ }Â´ nâŠ¸Ã·Â¨ 1â†“â†•n
    ğ•©
  }) _mkMultivector

  Divide â‡ { Inverse ğ•© ; ğ•¨ GeometricProduct Inverse ğ•© }

  Length â‡ { âˆš | One ğ•© GeometricProduct Conjugate ğ•© } _mkMultivector
  Normalize â‡ { ğ•© Ã— Ã· Length ğ•© }
  
  Sandwich â‡ { ğ•¨ GeometricProduct ğ•© GeometricProduct Reverse ğ•¨ }
}
